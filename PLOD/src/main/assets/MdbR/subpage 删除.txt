
function wrappedClickFunc(e){
	//if(1)return;
	if(url2Jump) {
		if(!frameElement || frameElement.dictInfo.scrollExpand) JumpUrl(url2Jump);
		url2Jump=0;
	}
	//parent.window.dismiss_menu();
	//parent.dismiss_menu();
	var cur=e.srcElement;
	if(0)
	if(cur.href){
		debug("1! found link : "+cur.href+" : "+regSound.test(cur.href));
		var getRawLink=cur.href;
		var patt1 = /\/base\/[0-9]*\/(#.*)/;
		var m = getRawLink.match(patt1);
		if(m && m[0].length>0){
			debug(m[1]);
			getRawLink=m[1];
			debug(window.location.href);
			cur.href=window.location.href+getRawLink;
			return false;
		}
		if(regEntry.test(cur.href)){
			cur.href="entry/"+cur.href.substring(8);
			debug("entry::", cur.href);
		}else if(regSound.test(cur.href)){/*拦截 sound 连接*/
			var link=/* "sound/"+ */cur.href.substring(8);
			cur.href=link;
			if(cur.onclick==undefined){
				//debug("1! found internal sound link : "+cur.href);
				cur.ur1=cur.href;
				cur.removeAttribute("href");
				cur.onclick=hiPlaySound;
				hiPlaySound(cur)
				return false;
			}
		}
		else if(parent.app && regHttp.test(cur.href)){/*拦截 http*/
			parent.app.handleWebLink(cur.href);
			return false;
		}
		else if(parent.app && regPdf.test(cur.href)){/*拦截 pdf*/
			parent.app.handlePdfLink(cur.href);
			return false;
		}
		return true;/*连接通行！*/
	}
	else if(cur.src && regEntry.test(cur.src)){
		debug("2! found link : "+cur.src);
		return false;
	}
	else if(e.srcElement!=document.documentElement && e.srcElement.nodeName!='INPUT'){ // immunize blank area out of body ( in html )
		//debug(e.srcElement+'')
		//debug(e);
		var s = window.getSelection();
		if(s.isCollapsed && s.anchorNode){ // don't bother with user selection
			s.modify('extend', 'forward', 'word'); // first attempt
			//if(1) return;
			var an=s.anchorNode;
			//debug(s.anchorNode); debug(s);  debug(s.getRangeAt(0)); debug(s+'');
			fixPdfForword(s);
			if(s.baseNode != document.body) {// immunize blank area
				var scer=s.getRangeAt(0);
				if(scer.startOffset==0){
					scer=scer.startContainer;
					if(scer.nodeType==3){
						scer=scer.parentNode;
					}
					if(scer.previousSibling==null){
						debug(e.clientX-scer.offsetLeft, e.clientY-scer.offsetTop);
						if(Math.abs(e.clientX-scer.offsetLeft)>50||Math.abs(e.clientY-scer.offsetTop)>50){
							s.empty();
							scer=null;
						}
					}
				}
				if(scer){
					scer=0;
					var text=s.toString(); // for word made up of just one character
					if(text.length>0){
						var re=/[\u4e00-\u9fa5]/g;
						tillNext=text;
						if(re.test(text.trim())){
							scer=1;
						}else{
							var range = s.getRangeAt(0);  // first attempt, forward range
							//debug(range);
							var lb='lineboundary';
							s.collapseToStart();
							s.modify('extend', 'forward', lb);
							tillNextLine=s.toString();
							var eN='word';
							var eB='word';
							if(tillNextLine.trim()!="") {
								s.collapseToStart();
								s.modify('extend', 'backward', 'word');
								tillNext=s.toString();
								s.collapseToEnd();
								s.modify('extend', 'backward', lb);
								tillNextLine=s.toString();
								
								// !!!  !!! sometime in the pdf
								// a lot of tags till be wrongly treated as in one line.
								if(tillNextLine.length<tillNext.length){
									var code=tillNextLine.charAt(0);
									if(code.toUpperCase()===code && code.toLowerCase!=code) eB=lb;
								}
							
								s.empty(); s.addRange(range);
								s.collapseToStart();
								
								
								s.modify('move', 'backward', eB);
								
								s.modify('extend', 'forward', 'word');
								tillNext=s.toString();
								s.collapseToStart();
								s.modify('extend', 'forward', lb);
								tillNextLine=s.toString();
								
								// !!!  !!! sometime in the pdf
								// a lot of tags till be wrongly treated as in one line.
								if(tillNextLine.length<tillNext.length){
									var code=tillNext.charAt(tillNextLine.length);
									if(code.toUpperCase()==code && code.toLowerCase()!=code) eN=lb;
								}
								s.collapseToStart();
								
								s.modify('extend', 'forward', eN);
								
								text=s.toString();
								scer=1;
							}
						}
						if(scer){
							debug(text); // final output
						}
					}
				}
			}
			//s.empty();
		}
	}
	return false;
};

function fixPdfForword(s){
	var r = s.getRangeAt(0);
	if(r.startContainer!=r.endContainer){
		r.setEndAfter(r.startContainer);
	}
}
function fixPdfBackword(s){
	var r = s.getRangeAt(0);
	if(r.startContainer!=r.endContainer){
		r.setStartBefore(r.endContainer);
	}
}
